The Question:
Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.
One of the given test cases:

Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]
Output: 6

First thoughts :
1) Obvious constraint: Two walls (containing inner walls /blocks) can be treated as a minimum viable storage unit 
2) In a set of two walls the smaller of either left or right determines the max height of water else it overflows.
3) Monotonic Nature: We initialise a left wall or reuse the previous right wall for the next one.The closest right wall is when next block is taller than the most recent addition to the stack
4)Two pointer mechanism:Have a left pointer and right pointer.In a set go column by column and sum the difference between smaller wall height and current strip
5) Take care of the case where we are not able to find the right wall.This can happen in the end.Empty stack emulates this.

I went for the former approach though the two pointer is more intuitive 
Key difference between stack and two pointer: Two pointer has a "fixed" left wall while 
Another interesting thing is that the stack method pops a block before ALL the available/valid area above it is filled.That is possible when the block preceeding the left wall is higher than the current wall.
Hence the need for width= i-left-1 (-1 since the walls themselves do not contribute to water at thant moment) and ans= ans+width*bounded.


#include <vector>
#include <stack>
#include <iostream>

using namespace std;

class Solution {
public:
    int trap(vector<int>& height) {
        int n = height.size();
        if (n == 0) return 0;  // guard empty input

        stack<int> st;
        long long ans = 0;

        for (int i = 0; i < n; i++) {
            while (!st.empty() && height[i] > height[st.top()]) {
                int mid = st.top(); 
                st.pop();
                if (st.empty()) break;

                int left = st.top();
                int width = i - left - 1;
                int bounded = min(height[left], height[i]) - height[mid];
                if (bounded > 0) ans +=  width * bounded;
            }
            st.push(i);
        }
        return (int)ans;
    }
};
