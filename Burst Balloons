Problem 
You are given n balloons, indexed from 0 to n - 1. Each balloon is painted with a number on it represented by an array nums. You are asked to burst all the balloons.
If you burst the ith balloon, you will get nums[i - 1] * nums[i] * nums[i + 1] coins. If i - 1 or i + 1 goes out of bounds of the array, then treat it as if there is a balloon with a 1 painted on it.
Return the maximum coins you can collect by bursting the balloons wisely.

 
1 Test Case 
Input: nums = [3,1,5,8]
Output: 167
Explanation:
nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> []
coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167


First Thoughts:
1)Confusing as the array itself is altered post burst so greedy fails.
2)Key realisation:Impossible to tell which balloon to burst first directly  but may be possible to tell which balloon not to burst 
3)0 <= nums[i] <= 100 means that O(nk),O(nlogn) and even O(n^2) Time complexity is allowed
4)Interval based Problem not global/value of element based.

Key Idea: 
Let dp[l][r] be the max coins from bursting only the balloons strictly between l and r (open interval (l, r)).
If k is the last balloon burst inside (l, r), then:
left side contributes dp[l][k]
right side contributes dp[k][r]
bursting k last gives a[l] * a[k] * a[r] (because its neighbors are exactly l and r at that moment)
DP over intervals simulates all orders by choosing the last k for each (l, r).


Note:I was unable to solve this problem on my own.Had difficulty recognising this is a Dynamic Programming Problem.Referred to LC discussion to understand and present the solution.
    The genius of this problem is that all the possible subsets are represented as a coordinate on the matrix and the ability to explore multiple elements and indirectly apply greedy.
    Plus instead of shortening the interval we actually increase the gap of the interval.


The code:

#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int maxCoins(vector<int>& nums) {
        vector<int> a;
        a.reserve(nums.size() + 2);
        a.push_back(1);
        for (int x : nums) if (x > 0) a.push_back(x); 
        a.push_back(1);

        int n = (int)a.size();
        vector<vector<int>> dp(n, vector<int>(n, 0));

        for (int gap = 2; gap < n; ++gap) {       
            for (int l = 0; l + gap < n; ++l) {
                int r = l + gap;
                int best = 0;
                for (int k = l + 1; k < r; ++k) {
                    best = max(best, dp[l][k] + dp[k][r] + a[l] * a[k] * a[r]);
                }
                dp[l][r] = best;
            }
        }
        return dp[0][n - 1];
    }
};
